
R version 2.11.1 (2010-05-31)
Copyright (C) 2010 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ###
> # check families
> 
> require("gamboostLSS")
Loading required package: gamboostLSS
Loading required package: mboost
Loading required package: survival
Loading required package: splines
> require("gamlss")
Loading required package: gamlss
Loading required package: gamlss.dist
Loading required package: gamlss.data
 **********   GAMLSS Version 4.0-0 ********** 
For more on GAMLSS look at http://www.gamlss.com/ 
Type gamlssNews() to see new features/changes/bug fixes.

Attaching package: 'gamlss'

The following object(s) are masked from 'package:survival':

    ridge

> 
> 
> ### check families with only one offset specified (other to choose via optim)
> set.seed(1907)
> n <- 5000
> x1  <- runif(n)
> x2 <- runif(n)
> mu <- 2 -1*x1 - 3*x2
> sigma <- exp(-1*x1 + 3*x2)
> df <- exp(1 + 3*x1 + 1*x2)
> y <- rTF(n = n, mu = mu, sigma = sigma, nu = df)
> 
> #model <- glmboostLSS(y ~ x1 + x2, families = StudentTLSS(mu = 10),
> #                     control = boost_control(mstop = 10))
> 
> 
> 
> ### check survival families
> 
> # LogNormalLSS()
> x1 <- runif(1000)
> x2 <- runif(1000)
> x3 <- runif(1000)
> w <- rnorm(1000)
> 
> time <-  exp(3 + 1*x1 +2*x2  + exp(0.2 * x3) * w)
> status <- rep(1, 1000)
> (m1 <- survreg(Surv(time, status) ~ x1 + x2 + x3, dist="lognormal"))
Call:
survreg(formula = Surv(time, status) ~ x1 + x2 + x3, dist = "lognormal")

Coefficients:
(Intercept)          x1          x2          x3 
 2.88588933  1.15548098  2.03642866  0.09869623 

Scale= 1.135837 

Loglik(model)= -6051   Loglik(intercept only)= -6199.6
	Chisq= 297.2 on 3 degrees of freedom, p= 0 
n= 1000 
> model <- glmboostLSS(Surv(time, status) ~ x1 + x2 + x3, families = LogNormalLSS(),
+                      control = boost_control(trace = TRUE))
[   1] ...................................... -- risk: 1552.035 
[  41] ...................................... -- risk: 1543.920 
[  81] ..................
Final risk: 1543.558 
> stopifnot(sum(abs(coef(model, off2int = TRUE)[[1]] - c(3, 1, 2, 0)))
+           < sum(abs(coef(m1) - c(3, 1, 2, 0))))
> stopifnot(sum(abs(coef(model, off2int = TRUE)[[2]] - c(0, 0, 0, 0.2))) < 0.25)
> 
> # LogLogLSS()
> etamu <- 3 + 1*x1 +2*x2
> etasi <- exp(rep(0.2, 1000))
> for (i in 1:1000)
+     time[i] <- exp(rlogis(1, location = etamu[i], scale = etasi[i]))
> status <- rep(1, 1000)
> (m1 <- survreg(Surv(time, status) ~ x1 + x2 + x3, dist="loglogistic"))
Call:
survreg(formula = Surv(time, status) ~ x1 + x2 + x3, dist = "loglogistic")

Coefficients:
(Intercept)          x1          x2          x3 
  3.2109423   0.6543336   2.0799870  -0.2505811 

Scale= 1.257854 

Loglik(model)= -6681.6   Loglik(intercept only)= -6721.9
	Chisq= 80.57 on 3 degrees of freedom, p= 0 
n= 1000 
> model <- glmboostLSS(Surv(time, status) ~ x1 + x2 + x3, families = LogLogLSS(),
+                      control = boost_control(trace = TRUE))
[   1] ...................................... -- risk: 2246.602 
[  41] ...................................... -- risk: 2240.116 
[  81] ..................
Final risk: 2238.513 
> model[350]
[ 101] ...................................... -- risk: 2236.762 
[ 141] ...................................... -- risk: 2235.899 
[ 181] ...................................... -- risk: 2235.418 
[ 221] ...................................... -- risk: 2235.150 
[ 261] ...................................... -- risk: 2235.002 
[ 301] ...................................... -- risk: 2234.919 
[ 341] ........
Final risk: 2234.905 

	 Generalized Linear Models Fitted via Gradient Boosting

Call:
glmboost.formula(formula = formula[[names(families)[[j]]]], data = data,     weights = w, control = control, family = families[[j]])


	 Log-Logistic AFT Model: mu (id link) 

Loss function: { 
     logfw <- function(pred) dlogis(pred, log = TRUE) 
     logSw <- function(pred) plogis(pred, lower.tail = FALSE,  
         log.p = TRUE) 
     eta <- (log(y[, 1]) - f)/sigma 
     -y[, 2] * (logfw(eta) - log(sigma)) - (1 - y[, 2]) * logSw(eta) 
 } 
 

Number of boosting iterations: mstop = 350 
Step size:  0.1 
Offset:  4.428274 

Coefficients: 
(Intercept)          x1          x2          x3 
 -1.1736364   0.6072744   1.9915746  -0.2065566 
attr(,"offset")
[1] 4.428274


	 Generalized Linear Models Fitted via Gradient Boosting

Call:
glmboost.formula(formula = formula[[names(families)[[j]]]], data = data,     weights = w, control = control, family = families[[j]])


	 Log-Logistic AFT Model: sigma (log link) 

Loss function: { 
     logfw <- function(pred) dlogis(pred, log = TRUE) 
     logSw <- function(pred) pnorm(pred, lower.tail = FALSE, log.p = TRUE) 
     eta <- (log(y[, 1]) - mu)/exp(f) 
     -y[, 2] * (logfw(eta) - f) - (1 - y[, 2]) * logSw(eta) 
 } 
 

Number of boosting iterations: mstop = 350 
Step size:  0.1 
Offset:  0.2689448 

Coefficients: 
 (Intercept)           x1           x2           x3 
-0.043191263 -0.088159918  0.007866414  0.086310938 
attr(,"offset")
[1] 0.2689448

> stopifnot(sum(abs(coef(model, off2int = TRUE, which ="")[[1]] - c(3, 1, 2, 0)))
+           < sum(abs(coef(m1) - c(3, 1, 2, 0))))
> stopifnot(sum(abs(coef(model, off2int = TRUE)[[2]] - c(0.2, 0, 0, 0))) < 0.25)
> 
> # WeibullLSS()
> etamu <- 3 + 1*x1 +2*x2
> etasi <- exp(rep(0.2, 1000))
> status <- rep(1, 1000)
> time <- rep(NA, 1000)
> for (i in 1:1000)
+     time[i] <- rweibull(1, shape = exp(- 0.2), scale = exp(etamu[i]))
> (m1 <- survreg(Surv(time, status) ~ x1 + x2 + x3, dist="weibull"))
Call:
survreg(formula = Surv(time, status) ~ x1 + x2 + x3, dist = "weibull")

Coefficients:
 (Intercept)           x1           x2           x3 
 3.047471670  1.008282745  1.934326789 -0.007107055 

Scale= 1.230652 

Loglik(model)= -5567.4   Loglik(intercept only)= -5684.9
	Chisq= 235.11 on 3 degrees of freedom, p= 0 
n= 1000 
> model <- glmboostLSS(Surv(time, status) ~ x1 + x2 + x3,
+                      families = WeibullLSS(),
+                      control = boost_control(trace = TRUE))
[   1] ...................................... -- risk: 1803.967 
[  41] ...................................... -- risk: 1780.522 
[  81] ..................
Final risk: 1776.832 
> model[300]
[ 101] ...................................... -- risk: 1774.304 
[ 141] ...................................... -- risk: 1773.746 
[ 181] ...................................... -- risk: 1773.615 
[ 221] ...................................... -- risk: 1773.577 
[ 261] ......................................
Final risk: 1773.565 

	 Generalized Linear Models Fitted via Gradient Boosting

Call:
glmboost.formula(formula = formula[[names(families)[[j]]]], data = data,     weights = w, control = control, family = families[[j]])


	 Weibull AFT Model: mu (id link) 

Loss function: { 
     logfw <- function(pred) pred - exp(pred) 
     logSw <- function(pred) -exp(pred) 
     eta <- (log(y[, 1]) - f)/sigma 
     -y[, 2] * (logfw(eta) - log(sigma)) - (1 - y[, 2]) * logSw(eta) 
 } 
 

Number of boosting iterations: mstop = 300 
Step size:  0.1 
Offset:  4.804055 

Coefficients: 
(Intercept)          x1          x2          x3 
-1.80328101  1.03767254  2.01525023 -0.01837571 
attr(,"offset")
[1] 4.804055


	 Generalized Linear Models Fitted via Gradient Boosting

Call:
glmboost.formula(formula = formula[[names(families)[[j]]]], data = data,     weights = w, control = control, family = families[[j]])


	 Weibull AFT Model: sigma (log link) 

Loss function: { 
     logfw <- function(pred) pred - exp(pred) 
     logSw <- function(pred) -exp(pred) 
     eta <- (log(y[, 1]) - mu)/exp(f) 
     -y[, 2] * (logfw(eta) - f) - (1 - y[, 2]) * logSw(eta) 
 } 
 

Number of boosting iterations: mstop = 300 
Step size:  0.1 
Offset:  0.294634 

Coefficients: 
(Intercept)          x1          x2          x3 
-0.01296774 -0.06173852 -0.14768701  0.05033678 
attr(,"offset")
[1] 0.294634

> stopifnot(sum(abs(coef(model, off2int = TRUE, which ="")[[1]] - c(3, 1, 2, 0)))
+           < sum(abs(coef(m1) - c(3, 1, 2, 0))))
> stopifnot(sum(abs(coef(model, off2int = TRUE)[[2]] - c(0.2, 0, 0, 0))) < 0.4)
> 
> ### Check that "families"-object contains a response function
> NBinomialMu2 <- function(...){
+     RET <- NBinomialMu(...)
+     RET@response <- function(f) NA
+     RET
+ }
> 
> NBinomialSigma2 <- function(...){
+     RET <- NBinomialSigma(...)
+     RET@response <- function(f) NA
+     RET
+ }
> 
> NBinomialLSS2 <- function(mu = NULL, sigma = NULL){
+     if ((!is.null(sigma) && sigma <= 0) || (!is.null(mu) && mu <= 0))
+         stop(sQuote("sigma"), " and ", sQuote("mu"),
+              " must be greater than zero")
+     RET <- makeFamilies(mu = NBinomialMu2(mu = mu, sigma = sigma),
+                         sigma = NBinomialSigma2(mu = mu, sigma = sigma))
+     return(RET)
+ }
> 
> try(NBinomialLSS2())
Error in makeFamilies(mu = NBinomialMu2(mu = mu, sigma = sigma), sigma = NBinomialSigma2(mu = mu,  : 
  response function not specified in families for:
	mu, sigma
> 
> #detach("package:gamboostLSS", unload = TRUE)
> 
